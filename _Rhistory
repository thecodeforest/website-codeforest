y = start_lat,
label = drop_off_order
))
help("geom_label")
nyc_map +  geom_path(aes(x = start_lon, y = start_lat),
data = small_df,
size = 2) +
geom_label(data = small_df, aes(x = start_lon,
y = start_lat,
label = drop_off_order
),
label.padding = 0.1)
nyc_map +  geom_path(aes(x = start_lon, y = start_lat),
data = small_df,
size = 2) +
geom_text()
head(small_df)
row.names(small_df) = small_df$drop_off_order
nyc_map +  geom_path(aes(x = start_lon, y = start_lat),
data = small_df,
size = 2) +
geom_text()
small_df = head(travel_path_df, 40) %>%
mutate(drop_off_order = 1:n())
# start_lat
nyc_map +  geom_path(aes(x = start_lon, y = start_lat),
data = small_df,
size = 2) +
geom_label(data = small_df, aes(x = start_lon,
y = start_lat,
label = drop_off_order
),
label.padding = 0.1)
nyc_map +  geom_path(aes(x = start_lon, y = start_lat),
data = small_df,
size = 2) +
geom_label(data = small_df, aes(x = start_lon,
y = start_lat,
label = drop_off_order
))
small_df = head(travel_path_df, 80) %>%
mutate(drop_off_order = 1:n())
nyc_map +  geom_path(aes(x = start_lon, y = start_lat),
data = small_df,
size = 2) +
geom_label(data = small_df, aes(x = start_lon,
y = start_lat,
label = drop_off_order
))
leaflet(data = lat_long_man) %>%
setView(lng = -74.0060, lat = 40.7128, zoom = 12) %>%
addProviderTiles(providers$Stamen.Toner) %>%
addCircleMarkers(~long, ~lat,
color = ~pal(truck),
radius = 3,
stroke = TRUE,
fillOpacity = 0.5,
popup = ~as.character(paste(lat, long, zip_code, sep = " | "))
) %>%
addPopups(lng = -73.998247, lat = 40.723284, content,
options = popupOptions(closeButton = FALSE)
)
truck_1 = lat_long_man %>%
filter(truck == 'truck1') %>%
mutate(row_index = 1:n())
truck_1
leaflet(data = truck_1) %>%
setView(lng = -74.0060, lat = 40.7128, zoom = 12) %>%
addProviderTiles(providers$Stamen.Toner) %>%
addCircleMarkers(~long, ~lat,
color = ~pal(truck),
radius = 3,
stroke = TRUE,
fillOpacity = 0.5,
popup = ~as.character(paste(lat, long, zip_code, sep = " | "))
) %>%
addPopups(lng = -73.998247, lat = 40.723284, content,
options = popupOptions(closeButton = FALSE)
)
truck_1_small = truck_1 %>%
select(row_index, lat, long) %>%
rename(name = row_index,
lon = long)
truck_1_small = bind_rows(data.frame(name = 0,
lat = start_lat,
lon = start_lon
),
truck_1_small
)
# DOWNSAMPLE FOR ILLUSTRATIVE PURPOSES
truck_1_small = head(truck_1_small, 51)
head(truck_1_small)
leaflet(data = truck_1_small) %>%
setView(lng = -74.0060, lat = 40.7128, zoom = 12) %>%
addProviderTiles(providers$Stamen.Toner) %>%
addMarkers(~lon, ~lat, popup = ~as.character(name), label = ~as.character(name)) %>%
addPopups(lng = -73.998247, lat = 40.723284, content,
options = popupOptions(closeButton = TRUE)
)
man_dist_matrix = GeoDistanceInMetresMatrix(truck_1_small)
D = as.matrix(man_dist_matrix)
D
tourLength <- function(tour, distMatrix) {
tour <- c(tour, tour[1])
route <- embed(tour, 2)[,2:1]
sum(distMatrix[route])
}
tspFitness <- function(tour, ...) 1/tourLength(tour, ...)
# data("eurodist", package = "datasets")
# attr(eurodist, "Size")
GA <- ga(type = "permutation", fitness = tspFitness, distMatrix = D,
min = 1, max = nrow(truck_1_small), popSize = 50, maxiter = 5000,
run = 500, pmutation = 0.2)
mds <- cmdscale(man_dist_matrix)
drive_time_df = data.frame(NULL)
for(fname in list.files(file.path(base_dir, 'input_data'))){
if(length(grep("nyc_times_", fname)) == 1){
temp_df = read.csv(file.path(base_dir, 'input_data', fname))
drive_time_df = bind_rows(drive_time_df, temp_df)
}
}
head(drive_time_df)
order_by_hour = data.frame(table(demand_df$order_hour)) %>%
dplyr::rename(hour_of_day = Var1,
order_cnt = Freq) %>%
mutate(order_pct = order_cnt/nrow(demand_df) * 100)
ggplot(order_by_hour, aes(x = hour_of_day, y = order_pct)) +
geom_bar(stat = "identity") +
theme_bw() +
my_plot_theme() +
xlab("Hour of Day") +
ylab("Percent of Orders Received")
# BEGIN FUNCTIONS ---------------------------------------------------------
ReplaceLowerOrUpperTriangle <- function(m, triangle.to.replace){
# If triangle.to.replace="lower", replaces the lower triangle of a square matrix with its upper triangle.
# If triangle.to.replace="upper", replaces the upper triangle of a square matrix with its lower triangle.
if (nrow(m) != ncol(m)) stop("Supplied matrix must be square.")
if      (tolower(triangle.to.replace) == "lower") tri <- lower.tri(m)
else if (tolower(triangle.to.replace) == "upper") tri <- upper.tri(m)
else stop("triangle.to.replace must be set to 'lower' or 'upper'.")
m[tri] <- t(m)[tri]
return(m)
}
GeoDistanceInMetresMatrix <- function(df.geopoints){
# Returns a matrix (M) of distances between geographic points.
# M[i,j] = M[j,i] = Distance between (df.geopoints$lat[i], df.geopoints$lon[i]) and
# (df.geopoints$lat[j], df.geopoints$lon[j]).
# The row and column names are given by df.geopoints$name.
GeoDistanceInMetres <- function(g1, g2){
# Returns a vector of distances. (But if g1$index > g2$index, returns zero.)
# The 1st value in the returned vector is the distance between g1[[1]] and g2[[1]].
# The 2nd value in the returned vector is the distance between g1[[2]] and g2[[2]]. Etc.
# Each g1[[x]] or g2[[x]] must be a list with named elements "index", "lat" and "lon".
# E.g. g1 <- list(list("index"=1, "lat"=12.1, "lon"=10.1), list("index"=3, "lat"=12.1, "lon"=13.2))
DistM <- function(g1, g2){
require("Imap")
return(ifelse(g1$index > g2$index, 0, gdist(lat.1=g1$lat, lon.1=g1$lon, lat.2=g2$lat, lon.2=g2$lon, units="m")))
}
return(mapply(DistM, g1, g2))
}
n.geopoints <- nrow(df.geopoints)
# The index column is used to ensure we only do calculations for the upper triangle of points
df.geopoints$index <- 1:n.geopoints
# Create a list of lists
list.geopoints <- by(df.geopoints[,c("index", "lat", "lon")], 1:n.geopoints, function(x){return(list(x))})
# Get a matrix of distances (in metres)
mat.distances <- ReplaceLowerOrUpperTriangle(outer(list.geopoints, list.geopoints, GeoDistanceInMetres), "lower")
# Set the row and column names
rownames(mat.distances) <- df.geopoints$name
colnames(mat.distances) <- df.geopoints$name
return(mat.distances)
}
my_plot_theme = function(){
font_family = "Helvetica"
font_face = "bold"
return(theme(
axis.text.x = element_text(size = 18, face = font_face, family = font_family),
axis.text.y = element_text(size = 18, face = font_face, family = font_family),
axis.title.x = element_text(size = 20, face = font_face, family = font_family),
axis.title.y = element_text(size = 20, face = font_face, family = font_family),
strip.text.y = element_text(size = 18, face = font_face, family = font_family),
plot.title = element_text(size = 18, face = font_face, family = font_family),
legend.position = "top",
legend.title = element_text(size = 16,
face = font_face,
family = font_family),
legend.text = element_text(size = 14,
face = font_face,
family = font_family)
))
}
# BEGIN FUNCTIONS ---------------------------------------------------------
ReplaceLowerOrUpperTriangle <- function(m, triangle.to.replace){
# If triangle.to.replace="lower", replaces the lower triangle of a square matrix with its upper triangle.
# If triangle.to.replace="upper", replaces the upper triangle of a square matrix with its lower triangle.
if (nrow(m) != ncol(m)) stop("Supplied matrix must be square.")
if      (tolower(triangle.to.replace) == "lower") tri <- lower.tri(m)
else if (tolower(triangle.to.replace) == "upper") tri <- upper.tri(m)
else stop("triangle.to.replace must be set to 'lower' or 'upper'.")
m[tri] <- t(m)[tri]
return(m)
}
GeoDistanceInMetresMatrix <- function(df.geopoints){
# Returns a matrix (M) of distances between geographic points.
# M[i,j] = M[j,i] = Distance between (df.geopoints$lat[i], df.geopoints$lon[i]) and
# (df.geopoints$lat[j], df.geopoints$lon[j]).
# The row and column names are given by df.geopoints$name.
GeoDistanceInMetres <- function(g1, g2){
# Returns a vector of distances. (But if g1$index > g2$index, returns zero.)
# The 1st value in the returned vector is the distance between g1[[1]] and g2[[1]].
# The 2nd value in the returned vector is the distance between g1[[2]] and g2[[2]]. Etc.
# Each g1[[x]] or g2[[x]] must be a list with named elements "index", "lat" and "lon".
# E.g. g1 <- list(list("index"=1, "lat"=12.1, "lon"=10.1), list("index"=3, "lat"=12.1, "lon"=13.2))
DistM <- function(g1, g2){
require("Imap")
return(ifelse(g1$index > g2$index, 0, gdist(lat.1=g1$lat, lon.1=g1$lon, lat.2=g2$lat, lon.2=g2$lon, units="m")))
}
return(mapply(DistM, g1, g2))
}
n.geopoints <- nrow(df.geopoints)
# The index column is used to ensure we only do calculations for the upper triangle of points
df.geopoints$index <- 1:n.geopoints
# Create a list of lists
list.geopoints <- by(df.geopoints[,c("index", "lat", "lon")], 1:n.geopoints, function(x){return(list(x))})
# Get a matrix of distances (in metres)
mat.distances <- ReplaceLowerOrUpperTriangle(outer(list.geopoints, list.geopoints, GeoDistanceInMetres), "lower")
# Set the row and column names
rownames(mat.distances) <- df.geopoints$name
colnames(mat.distances) <- df.geopoints$name
return(mat.distances)
}
my_plot_theme = function(){
font_family = "Helvetica"
font_face = "bold"
return(theme(
axis.text.x = element_text(size = 18, face = font_face, family = font_family),
axis.text.y = element_text(size = 18, face = font_face, family = font_family),
axis.title.x = element_text(size = 20, face = font_face, family = font_family),
axis.title.y = element_text(size = 20, face = font_face, family = font_family),
strip.text.y = element_text(size = 18, face = font_face, family = font_family),
plot.title = element_text(size = 18, face = font_face, family = font_family),
legend.position = "top",
legend.title = element_text(size = 16,
face = font_face,
family = font_family),
legend.text = element_text(size = 14,
face = font_face,
family = font_family)
))
}
# END FUNCTIONS -----------------------------------------------------------
libs = c('ggplot2', 'lubridate',
'data.table', 'janitor',
'ggforce', 'geosphere',
'reshape','forecast','dplyr',
'leaflet', "GA", "outliers"
)
lapply(libs, require, character.only = TRUE)
base_dir = "/Users/mlebo1/Desktop/begin_new/geocode_keycities"
data_dir = "analysis_data"
plot_dir = "nyc_plots"
demand_by_time_name = "nyc_orders_lat_long.csv"
demand_df = fread(file.path(base_dir,
data_dir,
demand_by_time_name
),
data.table = FALSE
) %>%
clean_names() %>%
mutate(city = tolower(city),
ordered_qty = 1)
head(demand_df)
demand_df$order_dt = lubridate::ymd_hms(demand_df$order_dt)
demand_df = demand_df %>%
mutate(day_date = lubridate::date(order_dt),
order_year = lubridate::year(order_dt),
order_month = lubridate::month(order_dt),
order_day = lubridate::day(order_dt),
order_hour = lubridate::hour(order_dt)
)
head(demand_df)
horizon = 12
demand_monthly = demand_df %>%
group_by(order_year, order_month) %>%
mutate(min_month_date = min(day_date)) %>%
ungroup() %>%
group_by(order_year, order_month, min_month_date) %>%
summarise(ordered_qty = sum(ordered_qty)) %>%
data.frame() %>%
filter(min_month_date < "2017-11-01") %>%
select(-order_year, -order_month) %>%
mutate(value = "actual",
lwr = NA,
upr = NA
)
ts_input = ts(demand_monthly$ordered_qty,
frequency = 12)
ar_fit = auto.arima(ts_input)
stl_fit = stl(ts_input, s.window = "periodic", robust = TRUE)
stl_fcast = forecast(stl_fit,
h = horizon)
ar_fcast = forecast(ar_fit,
h = horizon)
h_fcast = ar_fcast$mean * 0.5 + stl_fcast$mean * 0.5
lwr = ar_fcast$lower[,1]* 0.5 + stl_fcast$lower[,1] * 0.5
upr = ar_fcast$upper[,1]* 0.5 + stl_fcast$upper[,1] * 0.5
forecast_monthly = data.frame(min_month_date = seq.Date(as.Date("2017-11-01"),
by = "month",
length.out = horizon),
ordered_qty = h_fcast,
value = "forecast",
lwr = lwr,
upr = upr
)
monthly_plot = bind_rows(demand_monthly,
forecast_monthly
)
zoom_dates = monthly_plot %>%
filter(value == 'forecast') %>%
pull(min_month_date)
ggplot(monthly_plot, aes(x = min_month_date, y = ordered_qty/1e3, color = value)) +
geom_point(size = 2) + geom_line(size = 2) +
#stat_smooth(method = "lm", se = FALSE, color = "black") +
theme_bw() +
my_plot_theme() +
xlab("Date") +
ylab("Monthly Order Quantity (K)") +
geom_ribbon(aes(ymin = lwr/1e3,
ymax = upr/1e3),
fill = "gray",
alpha = 0.2
) +
facet_zoom(x = min_month_date %in% zoom_dates)
# best case/worst case growth scenario
last_year_total = sum(monthly_plot %>%
filter(value == 'actual') %>%
tail(horizon) %>%
pull(ordered_qty))
lapply(libs, require, character.only = TRUE)
base_dir = "/Users/mlebo1/Desktop/begin_new/geocode_keycities"
data_dir = "analysis_data"
plot_dir = "nyc_plots"
# read in historical demand by day
demand_by_time_name = "nyc_orders_lat_long_no_swoosh.csv"
demand_df = fread(file.path(base_dir,
data_dir,
demand_by_time_name
),
data.table = FALSE
) %>%
clean_names() %>%
mutate(city = tolower(city),
ordered_qty = 1)
head(demand_df)
unique(demand_df$carrier_service_code)
table(demand_df$carrier_service_code)
data.frame(table(demand_df$carrier_service_code))
lapply(libs, require, character.only = TRUE)
base_dir = "/Users/mlebo1/Desktop/begin_new/geocode_keycities"
data_dir = "analysis_data"
plot_dir = "nyc_plots"
# read in historical demand by day
demand_by_time_name = "nyc_orders_lat_long_no_swoosh.csv"
demand_df = fread(file.path(base_dir,
data_dir,
demand_by_time_name
),
data.table = FALSE
) %>%
clean_names() %>%
mutate(city = tolower(city),
ordered_qty = 1)
data.frame(table(demand_df$carrier_service_code))
demand_df$order_dt = lubridate::ymd_hms(demand_df$order_dt)
demand_df = demand_df %>%
mutate(day_date = lubridate::date(order_dt),
order_year = lubridate::year(order_dt),
order_month = lubridate::month(order_dt),
order_day = lubridate::day(order_dt),
order_hour = lubridate::hour(order_dt)
)
head(demand_df)
horizon = 12
demand_monthly = demand_df %>%
group_by(order_year, order_month) %>%
mutate(min_month_date = min(day_date)) %>%
ungroup() %>%
group_by(order_year, order_month, min_month_date) %>%
summarise(ordered_qty = sum(ordered_qty)) %>%
data.frame() %>%
filter(min_month_date < "2017-11-01") %>%
select(-order_year, -order_month) %>%
mutate(value = "actual",
lwr = NA,
upr = NA
)
ts_input = ts(demand_monthly$ordered_qty,
frequency = 12)
ar_fit = auto.arima(ts_input)
stl_fit = stl(ts_input, s.window = "periodic", robust = TRUE)
stl_fcast = forecast(stl_fit,
h = horizon)
ar_fcast = forecast(ar_fit,
h = horizon)
h_fcast = ar_fcast$mean * 0.5 + stl_fcast$mean * 0.5
lwr = ar_fcast$lower[,1]* 0.5 + stl_fcast$lower[,1] * 0.5
upr = ar_fcast$upper[,1]* 0.5 + stl_fcast$upper[,1] * 0.5
forecast_monthly = data.frame(min_month_date = seq.Date(as.Date("2017-11-01"),
by = "month",
length.out = horizon),
ordered_qty = h_fcast,
value = "forecast",
lwr = lwr,
upr = upr
)
monthly_plot = bind_rows(demand_monthly,
forecast_monthly
)
ggplot(monthly_plot, aes(x = min_month_date, y = ordered_qty/1e3, color = value)) +
geom_point(size = 2) + geom_line(size = 2) +
#stat_smooth(method = "lm", se = FALSE, color = "black") +
theme_bw() +
my_plot_theme() +
xlab("Date") +
ylab("Monthly Order Quantity (K)") +
geom_ribbon(aes(ymin = lwr/1e3,
ymax = upr/1e3),
fill = "gray",
alpha = 0.2
) +
facet_zoom(x = min_month_date %in% zoom_dates) +
theme(legend.position = element_blank())
head(demand_df)
head(demand_df)
ts_input = ts(demand_monthly$ordered_qty,
frequency = 12)
ar_fit = auto.arima(ts_input)
stl_fit = stl(ts_input, s.window = "periodic", robust = TRUE)
stl_fcast = forecast(stl_fit,
h = horizon)
ar_fcast = forecast(ar_fit,
h = horizon)
h_fcast = ar_fcast$mean * 0.5 + stl_fcast$mean * 0.5
lwr = ar_fcast$lower[,1]* 0.5 + stl_fcast$lower[,1] * 0.5
upr = ar_fcast$upper[,1]* 0.5 + stl_fcast$upper[,1] * 0.5
forecast_monthly = data.frame(min_month_date = seq.Date(as.Date("2017-11-01"),
by = "month",
length.out = horizon),
ordered_qty = h_fcast,
value = "forecast",
lwr = lwr,
upr = upr
)
monthly_plot = bind_rows(demand_monthly,
forecast_monthly
)
head(monthly_plot)
ggplot(monthly_plot, aes(x = min_month_date, y = ordered_qty/1e3, color = value)) +
geom_point(size = 2) + geom_line(size = 2) +
#stat_smooth(method = "lm", se = FALSE, color = "black") +
theme_bw() +
my_plot_theme() +
xlab("Date") +
ylab("Monthly Order Quantity (K)") +
geom_ribbon(aes(ymin = lwr/1e3,
ymax = upr/1e3),
fill = "gray",
alpha = 0.2
) +
facet_zoom(x = min_month_date %in% zoom_dates) +
theme(legend.position = element_blank())
ggplot(monthly_plot, aes(x = min_month_date, y = ordered_qty/1e3, color = value)) +
geom_point(size = 2) + geom_line(size = 2) +
#stat_smooth(method = "lm", se = FALSE, color = "black") +
theme_bw() +
my_plot_theme() +
xlab("Date") +
ylab("Monthly Order Quantity (K)") +
geom_ribbon(aes(ymin = lwr/1e3,
ymax = upr/1e3),
fill = "gray",
alpha = 0.2
)
ggplot(monthly_plot, aes(x = min_month_date, y = ordered_qty/1e3, color = value)) +
geom_point(size = 2) + geom_line(size = 2) +
#stat_smooth(method = "lm", se = FALSE, color = "black") +
theme_bw() +
my_plot_theme() +
xlab("Date") +
ylab("Monthly Order Quantity (K)") +
geom_ribbon(aes(ymin = lwr/1e3,
ymax = upr/1e3),
fill = "gray",
alpha = 0.2
) +
facet_zoom(x = min_month_date %in% zoom_dates) +
theme(legend.position = element_blank())
library(blogdown)
library(kableExtra)
library(rmarkdown)
library(png)
library(raster)
library(devtools)
library(dplyr)
library(VSURF)
library(quantregForest)
library(broom)
library(merTools)
library(lubridate)
setwd('/Users/mlebo1/Desktop/Site')
blogdown::serve_site()
servr::daemon_stop("4380103408")
